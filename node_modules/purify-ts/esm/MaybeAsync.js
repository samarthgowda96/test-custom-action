var _a;
import { Maybe, Just, Nothing } from './Maybe.js';
import { EitherAsync } from './EitherAsync.js';
const helpers = {
    liftMaybe(maybe) {
        if (maybe.isJust()) {
            return Promise.resolve(maybe.extract());
        }
        throw Nothing;
    },
    fromPromise(promise) {
        return promise.then(helpers.liftMaybe);
    }
};
class MaybeAsyncImpl {
    constructor(runPromise) {
        this.runPromise = runPromise;
        this[_a] = 'MaybeAsync';
        this['fantasy-land/chain'] = this.chain;
        this['fantasy-land/filter'] = this.filter;
        this['fantasy-land/alt'] = this.alt;
    }
    orDefault(defaultValue) {
        return this.run().then((x) => x.orDefault(defaultValue));
    }
    join() {
        return MaybeAsync(async (helpers) => {
            const maybe = await this.run();
            if (maybe.isJust()) {
                const nestedMaybe = await maybe.extract();
                return helpers.liftMaybe(nestedMaybe);
            }
            return helpers.liftMaybe(Nothing);
        });
    }
    ap(maybeF) {
        return MaybeAsync(async (helpers) => {
            const otherValue = await maybeF;
            if (otherValue.isJust()) {
                const thisValue = await this.run();
                if (thisValue.isJust()) {
                    return otherValue.extract()(thisValue.extract());
                }
                else {
                    return helpers.liftMaybe(Nothing);
                }
            }
            return helpers.liftMaybe(Nothing);
        });
    }
    alt(other) {
        return MaybeAsync(async (helpers) => {
            const thisValue = await this.run();
            if (thisValue.isJust()) {
                return thisValue.extract();
            }
            else {
                const otherValue = await other;
                return helpers.liftMaybe(otherValue);
            }
        });
    }
    extend(f) {
        return MaybeAsync(async (helpers) => {
            const maybe = await this.run();
            if (maybe.isJust()) {
                const v = MaybeAsync.liftMaybe(maybe);
                return helpers.liftMaybe(Just(f(v)));
            }
            return helpers.liftMaybe(Nothing);
        });
    }
    filter(pred) {
        return MaybeAsync(async (helpers) => {
            const value = await this.run();
            return helpers.liftMaybe(value.filter(pred));
        });
    }
    async run() {
        try {
            return Just(await this.runPromise(helpers));
        }
        catch {
            return Nothing;
        }
    }
    map(f) {
        return MaybeAsync((helpers) => this.runPromise(helpers).then(f));
    }
    chain(f) {
        return MaybeAsync(async (helpers) => {
            const value = await this.runPromise(helpers);
            return helpers.fromPromise(f(value));
        });
    }
    toEitherAsync(error) {
        return EitherAsync(async ({ liftEither }) => {
            const maybe = await this.run();
            return liftEither(maybe.toEither(error));
        });
    }
    ifJust(effect) {
        return MaybeAsync(async (helpers) => {
            const maybe = await this.run();
            maybe.ifJust(effect);
            return helpers.liftMaybe(maybe);
        });
    }
    ifNothing(effect) {
        return MaybeAsync(async (helpers) => {
            const maybe = await this.run();
            maybe.ifNothing(effect);
            return helpers.liftMaybe(maybe);
        });
    }
    void() {
        return this.map((_) => { });
    }
    caseOf(patterns) {
        return this.run().then((x) => x.caseOf(patterns));
    }
    finally(effect) {
        return MaybeAsync(({ fromPromise }) => fromPromise(this.run().finally(effect)));
    }
    then(onfulfilled, onrejected) {
        return this.run().then(onfulfilled, onrejected);
    }
}
_a = Symbol.toStringTag;
export const MaybeAsync = Object.assign((runPromise) => new MaybeAsyncImpl(runPromise), {
    catMaybes: (list) => Promise.all(list).then(Maybe.catMaybes),
    fromPromise: (f) => MaybeAsync(({ fromPromise: fP }) => fP(f())),
    liftMaybe: (maybe) => MaybeAsync(({ liftMaybe }) => liftMaybe(maybe))
});
MaybeAsyncImpl.prototype.constructor = MaybeAsync;
