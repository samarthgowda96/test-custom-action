import { Tuple } from './Tuple.js';
import { Maybe, Just, Nothing } from './Maybe.js';
import { orderToNumber } from './Function.js';
/** Returns Just the first element of an array or Nothing if there is none. If you don't want to work with a Maybe but still keep type safety, check out `NonEmptyList` */
const head = (list) => list.length > 0 ? Just(list[0]) : Nothing;
/** Returns Just the last element of an array or Nothing if there is none */
const last = (list) => list.length > 0 ? Just(list[list.length - 1]) : Nothing;
/** Returns all elements of an array except the first */
const tail = (list) => list.length > 0 ? Just(list.slice(1)) : Nothing;
/** Returns all elements of an array except the last */
const init = (list) => list.length > 0 ? Just(list.slice(0, -1)) : Nothing;
/** Returns a tuple of an array's head and tail */
const uncons = (list) => list.length > 0 ? Just(Tuple(list[0], list.slice(1))) : Nothing;
/* Returns the sum of all numbers inside an array */
const sum = (list) => list.reduce((acc, x) => acc + x, 0);
function find(f, list) {
    switch (arguments.length) {
        case 1:
            return (list) => find(f, list);
        default:
            return Maybe.fromNullable(list.find(f));
    }
}
function findIndex(f, list) {
    switch (arguments.length) {
        case 1:
            return (list) => findIndex(f, list);
        default:
            return Maybe.fromPredicate((x) => x !== -1, list.findIndex(f));
    }
}
function at(index, list) {
    switch (arguments.length) {
        case 1:
            return (list) => at(index, list);
        default:
            return list[index] === undefined ? Nothing : Just(list[index]);
    }
}
function sort(compare, list) {
    switch (arguments.length) {
        case 1:
            return (list) => sort(compare, list);
        default:
            return [...list].sort((x, y) => orderToNumber(compare(x, y)));
    }
}
export const List = {
    init,
    uncons,
    at,
    head,
    last,
    tail,
    find,
    findIndex,
    sum,
    sort
};
