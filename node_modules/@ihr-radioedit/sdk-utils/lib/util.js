/**
 * Not null, undefined, or empty string.
 */
export const notNullish = (value) => !!value || value === 0 || value === false;
/**
 * Convert a scalar-or-array parameter to array.
 */
export function vectorize(v) {
    if (v === null || v === undefined) {
        return Array();
    }
    return Array.isArray(v) ? v : [v];
}
/**
 * Super simple chunk function that is typed properly with generics. Accepts an array and
 * a length and returns an array of arrays, each of the input length. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export function chunk(arr, len) {
    const chunks = [];
    const n = arr.length;
    let i = 0;
    while (i < n) {
        chunks.push(arr.slice(i, (i += len)));
    }
    return chunks;
}
/**
 * Make a mostly random id for use within sub-documents to keep things straight.
 * This function won't work at scale, but it doesn't need to. It's fine!
 */
export function makeId(length = 5) {
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let text = "";
    for (let i = 0; i < length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
/**
 * Super simple group by function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export const groupBy = (input, by) => {
    return input.reduce((p, c) => {
        const k = by(c);
        p[k] = p[k] || [];
        p[k].push(c);
        return p;
    }, {});
};
/**
 * Super simple key by function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export const keyBy = (input, by) => {
    return input.reduce((p, c) => ({ ...p, [by(c)]: c }), {});
};
/**
 * Super simple flatten object function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export const flattenObj = (input) => {
    return Object.assign({}, ...input);
};
/**
 * Super simple map and reduce function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export const remapObj = (input, by) => {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, by(v)]));
};
/**
 * Creates a duplicate-free version of `iter`, using a `Map`-style key or the
 * result of `keyFn` equality comparisons, in which only the first occurence of
 * each element is kept.
 */
export const unique = (iter, keyFn) => iter.reduce(({ arr, set }, v) => {
    const k = keyFn ? keyFn(v) : v;
    if (!set.has(k)) {
        arr.push(v);
        set.add(k);
    }
    return { arr, set };
}, { arr: [], set: new Set() }).arr;
/**
 * Consistent key sorter for use with JSON.stringify and equivalents.
 */
export function sortedKeyReplacer(_, value) {
    return value instanceof Object && !Array.isArray(value)
        ? Object.fromEntries(Object.entries(value).sort((a, b) => a[0].localeCompare(b[0])))
        : value;
}
/**
 * This function takes keys, values and a key mapper function and will create a
 * Map where values have the key produced by the keyFn. If a key does not have a
 * matching value it will be null.
 */
export const zipMap = (keys, values, vToK, keyFn) => {
    const valueMap = new Map(values.map(v => [keyFn(vToK(v)), v]));
    return new Map(keys.map(k => [k, valueMap.get(keyFn(k)) ?? null]));
};
/**
 * Sort a list of inputs into a list of outputs based on a selector function.
 * Return a list of Options
 */
export const matchInputToOutput = (keys, vToK, keyFn, values) => {
    const map = zipMap(keys, values, vToK, keyFn);
    return keys.map(k => ({ k, v: map.get(k) }));
};
/**
 * Sort a list of inputs into a list of outputs based on a selector function.
 * Return a list of Options
 */
export const strictSortValues = (keys, values, vToK, keyFn, onMissing) => {
    const map = zipMap(keys, values, vToK, keyFn);
    return keys.map(k => map.get(k) ?? onMissing(k));
};
//# sourceMappingURL=util.js.map