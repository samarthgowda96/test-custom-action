/**
 * Not null, undefined, or empty string.
 */
export declare const notNullish: <T>(value: number | boolean | T | null | undefined) => value is T;
/**
 * Convert a scalar-or-array parameter to array.
 */
export declare function vectorize<T>(v: T | T[]): T[];
/**
 * Super simple chunk function that is typed properly with generics. Accepts an array and
 * a length and returns an array of arrays, each of the input length. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export declare function chunk<T>(arr: T[], len: number): T[][];
/**
 * Make a mostly random id for use within sub-documents to keep things straight.
 * This function won't work at scale, but it doesn't need to. It's fine!
 */
export declare function makeId(length?: number): string;
/**
 * Super simple group by function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export declare const groupBy: <T>(input: T[], by: (i: T) => string) => {
    [k: string]: T[];
};
/**
 * Super simple key by function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export declare const keyBy: <T>(input: T[], by: (i: T) => string) => Record<string, T>;
/**
 * Super simple flatten object function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export declare const flattenObj: <T>(input: Record<string, T>[]) => Record<string, T>;
/**
 * Super simple map and reduce function that is typed properly with generics. Keeps us
 * from having to outsource this super simple problem then fight with the types.
 */
export declare const remapObj: <T, U>(input: Record<string, T>, by: (i: T) => U) => Record<string, U>;
/**
 * Creates a duplicate-free version of `iter`, using a `Map`-style key or the
 * result of `keyFn` equality comparisons, in which only the first occurence of
 * each element is kept.
 */
export declare const unique: <T, U>(iter: T[], keyFn?: ((a: T) => U) | undefined) => T[];
/**
 * Consistent key sorter for use with JSON.stringify and equivalents.
 */
export declare function sortedKeyReplacer(_: string, value: unknown): unknown;
/**
 * This function takes keys, values and a key mapper function and will create a
 * Map where values have the key produced by the keyFn. If a key does not have a
 * matching value it will be null.
 */
export declare const zipMap: <K, V>(keys: readonly K[], values: readonly V[], vToK: (v: V) => K, keyFn: (k: K) => string) => Map<K, NonNullable<V> | null>;
/**
 * Sort a list of inputs into a list of outputs based on a selector function.
 * Return a list of Options
 */
export declare const matchInputToOutput: <K, V>(keys: readonly K[], vToK: (v: V) => K, keyFn: (k: K) => string, values: readonly V[]) => {
    k: K;
    v: NonNullable<V> | null | undefined;
}[];
/**
 * Sort a list of inputs into a list of outputs based on a selector function.
 * Return a list of Options
 */
export declare const strictSortValues: <K, V>(keys: readonly K[], values: readonly V[], vToK: (value: V) => K, keyFn: (key: K) => string, onMissing: (key: K) => V) => V[];
//# sourceMappingURL=util.d.ts.map