/**
 * Options for adding a key.
 */
export interface KeyAddOpts {
    excludePrefix?: true;
    priority?: number;
    group?: boolean;
}
/**
 * Clean a key by removing nullish segments and joining with a colon.
 */
export declare function cleanKey(segments: string[]): string;
/**
 * What we use to collect and dedupe surrogate keys while processing a request.
 */
export declare class KeyService {
    protected prefix: string[];
    /**
     * Whether to add segments of keys incrementally, e.g.
     * ```
     * false = ["prefix:addArg1:addArg2:addArg3"]
     *  true = ["prefix:addArg1", "prefix:addArg1:addArg2", "prefix:addArg1:addArg2:addArg3"]
     * ```
     */
    protected addGroupKeys: boolean;
    priorityKeys: Map<number, string[]>;
    constructor(prefix?: string[], 
    /**
     * Whether to add segments of keys incrementally, e.g.
     * ```
     * false = ["prefix:addArg1:addArg2:addArg3"]
     *  true = ["prefix:addArg1", "prefix:addArg1:addArg2", "prefix:addArg1:addArg2:addArg3"]
     * ```
     */
    addGroupKeys?: boolean);
    /**
     * Get all keys, sorted by priority and then alphabetically.
     */
    get keys(): string[];
    /**
     * Add a key.
     */
    add(segments: string[], opts?: KeyAddOpts): this;
    /**
     * Add all keys.
     */
    all(segments: string[][], opts?: KeyAddOpts): this;
    /**
     * Get a key.
     */
    keyFrom(segments: string[], excludePrefix?: boolean): string;
    /**
     * Extend keys from another KeyService.
     */
    extend(...others: KeyService[]): void;
    /**
     * Clear all keys.
     */
    clear(): void;
}
/**
 * This class is for determining the smallest cache TTL among multiple types of fetched data
 * (that might specify different cache times).
 */
export declare class LimboTTL {
    private fallback;
    private innerTTL;
    get ttl(): number;
    constructor(fallback: number);
    set: (k: number) => number;
    reset: () => null;
}
//# sourceMappingURL=skeys.d.ts.map