import { notNullish, unique } from "./util.js";
/**
 * Clean a key by removing nullish segments and joining with a colon.
 */
export function cleanKey(segments) {
    // The last line is to remove non-ASCII characters, @see IHRAR-7407
    return (segments
        .filter(notNullish)
        .join(":")
        //eslint-disable-next-line no-control-regex
        .replace(/[^\x00-\x7F]/g, ""));
}
/**
 * What we use to collect and dedupe surrogate keys while processing a request.
 */
export class KeyService {
    prefix;
    addGroupKeys;
    priorityKeys = new Map();
    constructor(prefix = [], 
    /**
     * Whether to add segments of keys incrementally, e.g.
     * ```
     * false = ["prefix:addArg1:addArg2:addArg3"]
     *  true = ["prefix:addArg1", "prefix:addArg1:addArg2", "prefix:addArg1:addArg2:addArg3"]
     * ```
     */
    addGroupKeys = false) {
        this.prefix = prefix;
        this.addGroupKeys = addGroupKeys;
    }
    /**
     * Get all keys, sorted by priority and then alphabetically.
     */
    get keys() {
        const flattened = Array.from(Array.from(this.priorityKeys.entries())
            .sort(([b], [a]) => a - b)
            .reduce((acc, [, priorityKeys]) => {
            priorityKeys.sort().forEach(k => acc.add(k));
            return acc;
        }, new Set()));
        return unique(flattened);
    }
    /**
     * Add a key.
     */
    add(segments, opts) {
        const priority = opts?.priority ?? 1;
        if (opts?.group ?? this.addGroupKeys) {
            segments.forEach((_, i) => {
                const key = this.keyFrom(segments.slice(0, segments.length - i), opts?.excludePrefix);
                if (key) {
                    const collection = this.priorityKeys.get(priority + i) ?? [];
                    collection.push(key);
                    this.priorityKeys.set(priority + i, collection);
                }
            });
        }
        else {
            const key = this.keyFrom(segments, opts?.excludePrefix);
            if (key) {
                const collection = this.priorityKeys.get(priority) ?? [];
                collection.push(key);
                this.priorityKeys.set(priority, collection);
            }
        }
        return this;
    }
    /**
     * Add all keys.
     */
    all(segments, opts) {
        segments.forEach(segment => this.add(segment, opts));
        return this;
    }
    /**
     * Get a key.
     */
    keyFrom(segments, excludePrefix = false) {
        return cleanKey([...(excludePrefix ? [] : this.prefix), ...segments]);
    }
    /**
     * Extend keys from another KeyService.
     */
    extend(...others) {
        others.map(other => {
            Array.from(other.priorityKeys.entries()).forEach(([priority, keys]) => {
                this.all(keys.map(k => [k]), { priority, excludePrefix: true, group: false });
            });
        });
    }
    /**
     * Clear all keys.
     */
    clear() {
        this.priorityKeys.clear();
    }
}
/**
 * This class is for determining the smallest cache TTL among multiple types of fetched data
 * (that might specify different cache times).
 */
export class LimboTTL {
    fallback;
    innerTTL = null;
    get ttl() {
        return this.innerTTL ?? this.fallback;
    }
    constructor(fallback) {
        this.fallback = fallback;
    }
    set = (k) => (this.innerTTL = this.innerTTL === null ? k : Math.min(this.ttl, k));
    reset = () => (this.innerTTL = null);
}
//# sourceMappingURL=skeys.js.map