/* eslint-disable @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */
/** Nano-Equal taken from https://github.com/NanoPackage/nano-equal with minor modifications */
/**
 * @licence
 * @author Sergey Melyukov @smelukov
 */
/**
 * Is value like array?
 *
 * @param a
 */
export function isArrayLike(a) {
    if (Array.isArray(a)) {
        return true;
    }
    const len = a.length;
    if (typeof len === "number" && len > -1) {
        if (len) {
            return 0 in a && len - 1 in a;
        }
        return true;
    }
    return false;
}
/**
 * Get type of value.
 *
 * @param a
 */
export function getType(a) {
    const type = typeof a;
    if (type === "object") {
        if (a === null) {
            return "null";
        }
        else if (isArrayLike(a)) {
            return "array";
        }
        else if (a.constructor === Object) {
            return "pure-object";
        }
        return "object";
    }
    return type;
}
/**
 * Deep equal of the values
 *
 * @param a
 * @param b
 */
export function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    // is nan
    if (a !== a && b !== b) {
        // eslint-disable-line no-self-compare
        return true;
    }
    const typeA = getType(a);
    const typeB = getType(b);
    if (typeA !== typeB) {
        return false;
    }
    if (typeA === "pure-object") {
        if (a === b) {
            return true;
        }
        const keysA = Object.keys(a);
        const keysBLength = Object.keys(b).length;
        if (keysA.length !== keysBLength) {
            return false;
        }
        for (let i = 0, l = keysA.length; i < l; i++) {
            const key = keysA[i];
            if (!Object.prototype.hasOwnProperty.call(b, keysA[i])) {
                return false;
            }
            const valA = a[key];
            const valB = b[key];
            // handle recursion
            if (valA === a || valB === b || valA === b || valB === a) {
                return valA === valB;
            }
            if (!deepEqual(valA, valB)) {
                return false;
            }
        }
        return true;
    }
    else if (typeA === "array") {
        if (a.length === b.length) {
            for (let j = 0; j < a.length; j++) {
                const elA = a[j];
                const elB = b[j];
                // handle recursion
                if (elA === a || elB === b || elA === b || elB === a) {
                    return elA === elB;
                }
                if (!deepEqual(elA, elB)) {
                    return false;
                }
            }
        }
        else {
            return false;
        }
        return true;
    }
    else if (typeA === "object") {
        if (a.valueOf !== Object.prototype.valueOf() && b.valueOf !== Object.prototype.valueOf()) {
            return a.valueOf() === b.valueOf();
        }
        if (a.toString !== Object.prototype.toString() && b.toString !== Object.prototype.toString()) {
            return a.toString() === b.toString();
        }
    }
    return false;
}
//# sourceMappingURL=equal.js.map