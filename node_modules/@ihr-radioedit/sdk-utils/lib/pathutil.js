const PATH_SEP = "/";
/**
 * Suffix match for strings.
 */
function hasSuffix(path) {
    return path.toString().slice(-1) === PATH_SEP;
}
/**
 * Prefix match for strings.
 */
function hasPrefix(path) {
    return path.toString().slice(0, 1) === PATH_SEP;
}
/**
 * Ensure that a path has no trailing separator.
 */
export function removeTrailingSep(path, removeRoot) {
    removeRoot = !!removeRoot;
    if (!hasSuffix(path)) {
        return path;
    }
    const withoutSep = path.toString().slice(0, -1);
    return removeRoot ? withoutSep : withoutSep || PATH_SEP;
}
// /**
//  * Ensure that a path has a trailing separator.
//  */
// export function addTrailingSep(path: string): string {
//     if (hasSuffix(path)) {
//         return path;
//     }
//     return path + PATH_SEP;
// }
/**
 * Ensure that a path has a leading separator.
 */
export function addLeadingSep(path) {
    if (hasPrefix(path)) {
        return path;
    }
    return PATH_SEP + path;
}
/**
 * Ensure that a path has no leading separator.
 */
export function removeLeadingSep(path) {
    if (!hasPrefix(path)) {
        return path;
    }
    return path.toString().slice(1);
}
// /**
//  * Get the directory portion of a path (with no trailing separator).
//  */
// export function dirname(path: string): string {
//     var index: number;
//     path = this.removeTrailingSep(path);
//     index = path.lastIndexOf(PATH_SEP);
//     return index > 0 ? path.slice(0, index) : PATH_SEP;
// }
// /**
//  * Get the final segment (basename) of a path.
//  */
// export function basename(path: string): string {
//     path = removeTrailingSep(path);
//     return path.split(PATH_SEP).pop();
// }
/**
 * Path join (dedupes separators, etc).
 */
export function joinPath(...parts) {
    // Remove trailing separator from all but the last
    // Remove leading separator from everything but the first.
    let path = "";
    parts
        .filter(p => !!p)
        .forEach((p, i, arr) => {
        if (i < arr.length - 1) {
            p = removeTrailingSep(p, false);
        }
        if (i > 0 && p) {
            p = removeLeadingSep(p);
            if (!hasSuffix(path)) {
                path += "/";
            }
        }
        path += p;
    });
    return path;
}
/**
 * Create a slug from an arbitrary string.
 * Untouched characters are alpha-numeric, dash (unless consecutive), and underscore.
 */
export function slugify(s) {
    return s
        .toLowerCase() // convert to lowercase
        .trim()
        .replace(/[^a-z0-9\s_-]/g, "") // remove everything but alphanum, space, underscore, and dash
        .replace(/[\s-]+/g, "-"); // replace runs of spaces and dashes with a single dash
}
//# sourceMappingURL=pathutil.js.map