import { bodyToJson, getClient, getServiceUrl, Scheme, } from "@ihr-radioedit/sdk-network";
import { removeLeadingSep } from "@ihr-radioedit/sdk-utils";
import { hasObserver } from "./security.js";
import { EitherAsync, Right } from "purify-ts";
export const SERVICE_ID = "auth";
/**
 * Returns true if a PrincipalObj is BUILTIN user/role id
 * @param p principal object
 * @return true if user/role id is BUILTIN
 */
export function isBuiltin(p) {
    return p._id.search(/(builtin|system)/) >= 0;
}
/**
 * Checks if a PrincipalObj is Administrator
 * @param p principal object
 * @return true if user is Administrator
 */
export function isAdmin(p) {
    return hasObserver(p.observer_of, "resource");
}
/**
 * Checks if a PrincipalObj is System Administrator
 * @param p principal object
 * @return true if user is System Administrator
 */
export function isSystemAdmin(p) {
    return hasObserver(p.observer_of, "users/role/builtin/administrators-members");
}
/**
 * Checks if an operation can be performed on PrincipalObj
 * @param p principal object
 * @param t AuthType
 * @return
 * @throws Will throw an error if an operation is incompatible
 */
function assertType(p, t) {
    if (p.type === t) {
        return;
    }
    throw new Error(`incompatible operation on principal=${p._id}; expected type=${t}`);
}
/**
 * Checks if a PrincipalObj can be mutated
 * @param p principal object
 * @param t Optional AuthType
 * @throws Will throw an error if Mutation attempt is made on a BUILTIN user/role id
 */
function assertEditable(p, t) {
    if (t) {
        assertType(p, t);
    }
    if (isBuiltin(p)) {
        throw new Error(`mutation attempt on built-in principal=${p._id}`);
    }
}
/**
 * Provides functions to work with PrincipalObj
 */
export class AuthClient {
    http;
    constructor(http) {
        this.http = http;
    }
    static auto(config) {
        return new AuthClient(getClient({
            ...config,
            defaultOptions: {
                baseUrl: getServiceUrl(SERVICE_ID, "", Scheme.SECURE),
                withCredentials: true,
                ...config?.defaultOptions,
            },
        }));
    }
    /**
     * Used to fetch principal data for the currently logged in user
     * @return A promise that contains User Data when fulfilled
     */
    getMyPrincipal() {
        return this.http.get(`me`).map(resp => resp.json());
    }
    /**
     * Used to fetch PrincipalObj Data for a given token
     * @param token Access token
     * @return A promise that contains User Data for the given token when fulfilled
     */
    getPrincipalForToken(token) {
        return this.http
            .get(`me`, { params: new URLSearchParams({ access_token: token }) })
            .map(resp => resp.json());
    }
    /**
     * Used to fetch Principal Data for a given principal id
     * @param id Principal id
     * @return A promise that contains User Data for the given id when fulfilled
     */
    getPrincipalById(id) {
        return this.http.get(`api/principals/${id}`).map(resp => resp.json());
    }
    /**
     * Accessor for principal search functionality.
     */
    get search() {
        return new PrincipalsSearchAPI(this.http);
    }
    /**
     * Used to create a new principal
     * @param properties principal data (varies by type)
     * @return A promise that contains User Data when fulfilled
     */
    createPrincipal(properties) {
        assertEditable(properties);
        return this.http
            .post(`api/principals`, ...bodyToJson(properties))
            .map(resp => resp.json());
    }
    /**
     * Accessor for principal management functionality.
     * @param p principal object
     */
    principal(p) {
        return new PrincipalAPI(this.http, p);
    }
}
/**
 * Provides API for searching PrincipalObj
 */
export class PrincipalsSearchAPI {
    http;
    path(suffix = "") {
        return `api/principals${suffix ? "/" + removeLeadingSep(suffix) : ""}`;
    }
    constructor(http) {
        this.http = http;
    }
    /**
     * Creates an encoded query for the given search options
     * @param options search options
     * @private
     * @return encoded query
     */
    createSpec(options) {
        const spec = options.spec ?? {};
        if (options.types && options.types.length > 1) {
            spec.type = { $in: options.types };
        }
        return btoa(JSON.stringify(spec));
    }
    /**
     * Fetch  list of principals along with count for the given memberships
     * @param members list of member/capability pairs
     * @param options search options
     * @return A promise that resolves to an object containing array of User Data objects when fulfilled
     */
    byMemberships(members, options) {
        // Optimize if the input is empty
        if (members.length === 0) {
            return EitherAsync.liftEither(Right({ count: 0, limit: 0, offset: 0, results: [] }));
        }
        const { matchAll, ...opts } = options;
        const firstCap = members[0]?.cap;
        // Optimize if all capabilities in the input are the same.
        if (!matchAll && members.every(x => x.cap === firstCap)) {
            return this.byQuery({
                ...opts,
                spec: {
                    observer_of: { $elemMatch: { mem: { $in: members.map(x => x.mem) }, cap: firstCap } },
                },
            });
        }
        // Otherwise we have to $and/$or it
        return this.byQuery({
            ...opts,
            spec: {
                [matchAll ? "$and" : "$or"]: members.map(({ mem, cap }) => ({
                    observer_of: {
                        $elemMatch: {
                            mem,
                            cap: cap ?? null,
                        },
                    },
                })),
            },
        });
    }
    /**
     * Fetch a list of principals along with count for the given query
     * @param options search options
     * @return A promise that resolves to an object containing array of User Data objects when fulfilled
     */
    byQuery(options) {
        const params = new URLSearchParams({
            q: options.q?.toString() ?? "",
            sort: options.sort?.join(",") ?? "",
            limit: options.limit?.toString() ?? "",
            offset: options.offset?.toString() ?? "",
            managed: options.managed ? "1" : "0",
            spec: this.createSpec(options),
        });
        return this.http
            .get(this.path(options.types?.length === 1 ? options.types[0] : ""), {
            params,
        })
            .map(resp => resp.json());
    }
    /**
     * Fetch a list of principals identified by the provided ids
     * @param ids list of principal ids
     * @return A promise that contains an object with an array or principals
     */
    byIds(ids) {
        const params = new URLSearchParams({ ids: ids.join(",") });
        return this.http.get(this.path(), { params }).map(resp => resp.json());
    }
}
/**
 * Provides CRUD operations for PrincipalObj
 */
export class PrincipalAPI {
    http;
    principal;
    constructor(http, principal) {
        this.http = http;
        this.principal = principal;
    }
    get path() {
        return `api/principals/${this.principal._id}`;
    }
    /**
     * Save a role for a PrincipalObj
     * @param properties role data
     * @return A promise containing user data when fulfilled
     */
    saveRole(properties) {
        assertEditable(this.principal, "role");
        return this.http
            .put(this.path, ...bodyToJson(properties))
            .map(resp => resp.json());
    }
    /**
     * Update a principal
     * @param properties principal data
     * @return A promise containing user data when fulfilled
     */
    saveUser(properties) {
        assertEditable(this.principal, "user");
        return this.http
            .put(this.path, ...bodyToJson(properties))
            .map(resp => resp.json());
    }
    /**
     * Delete roles for a principal
     * @return Empty Promise
     */
    remove() {
        assertEditable(this.principal);
        return this.http.delete(this.path).map(() => { });
    }
    /**
     * Gets a list of roles for a User
     * @param options search options
     * @return A promise that resolves to an object containing array of user data (id, name) objects
     */
    getRoles(options) {
        assertType(this.principal, "user");
        const params = new URLSearchParams(Object.entries(options));
        return this.http
            .get(`${this.path}/roles`, { params })
            .map(resp => resp.json());
    }
    /**
     * Gets a list of users for a role
     * @param options search options
     * @return A promise
     */
    getUsers(options) {
        assertType(this.principal, "role");
        const params = new URLSearchParams(Object.entries(options));
        return this.http.get(`${this.path}/users`, { params }).map(resp => resp.json());
    }
    /**
     * Add users to a role.
     * @param userIds list of user ids
     * @return Empty promise
     */
    addUsers(userIds) {
        assertEditable(this.principal, "role");
        if (userIds.length > 0) {
            return this.http
                .post(`${this.path}/users`, ...bodyToJson({ users: userIds.map(_id => ({ _id })) }, { params: new URLSearchParams({ limit: "1" }) }))
                .map(() => { });
        }
        return EitherAsync(async () => { });
    }
    /**
     * Remove roles from a user
     * @param userId user id
     * @return Empty promise
     */
    removeUser(userId) {
        assertEditable(this.principal, "role");
        return this.http
            .delete(`${this.path}/users/${userId}`, { params: new URLSearchParams({ limit: "1" }) })
            .map(() => { });
    }
    /**
     * List delegates for a user
     * @param options search options
     * @return A promise that resolves to an object containing array of User Data objects when fulfilled
     */
    getDelegates(options) {
        assertType(this.principal, "user");
        const params = new URLSearchParams(Object.entries(options));
        return this.http
            .get(`${this.path}/delegates`, { params })
            .map(resp => resp.json());
    }
    /**
     * Add the given users as delegates of a principal
     * @param userIds list of user ids
     * @return A promise that resolves to an object containing array of User Data objects when fulfilled
     */
    addDelegates(userIds) {
        assertEditable(this.principal, "user");
        if (userIds.length > 0) {
            return this.http
                .post(`${this.path}/delegates`, ...bodyToJson({ delegates: userIds.map(_id => ({ _id })) }, { params: new URLSearchParams({ limit: "1" }) }))
                .void();
        }
        return EitherAsync(async () => { });
    }
    /**
     * Remove a delegate from a user
     * @param userId user id
     * @return Empty promise
     */
    removeDelegate(userId) {
        assertEditable(this.principal, "user");
        return this.http
            .delete(`${this.path}/delegates/${userId}`, { params: new URLSearchParams({ limit: "1" }) })
            .map(() => { });
    }
    /**
     * Add observers to a principal
     * @param observers
     * @return A promise containing AuthObserver array when fulfilled
     */
    addObservers(observers) {
        assertEditable(this.principal);
        if (observers.length > 0) {
            return this.http
                .post(`${this.path}/observers`, ...bodyToJson({ observers }))
                .map(resp => resp.json())
                .map(data => data.observers);
        }
        return EitherAsync(async () => []);
    }
    /**
     * Remove an observer from a principal
     * @param mem member
     * @param cap capability
     * @return A promise containing the observer list when fulfilled
     */
    removeObserver(mem, cap) {
        assertEditable(this.principal);
        return this.http
            .delete(`${this.path}/observers/${mem}`, { params: new URLSearchParams({ ...(cap && { cap }) }) })
            .map(resp => resp.json())
            .map(data => data.observers);
    }
}
//# sourceMappingURL=client.js.map