# `@ihr-radioedit/logger`

<img src="../../logo.svg" width="350">

### Part of the [RadioEdit Library](../../README.md)

Setup, build and publish instructions located there.

## Purpose

Logging library for RadioEdit TypeScript applications, which provides a common interface for logging, and allows
for different logging libraries to be used under the hood as adapters. It supports child loggers, flexible
numeric log levels, and pretty printing, and provides helper methods for consistent log message rendering.

## Autogenerated Docs

Autogenerated documentation describing class structure and parameters available [here](../../docs/logger/README.md)

## Sample Code

### Default

When no adapters are registered (by importing them), a stub logger is returned which has noop methods. If an adapter
is later registered, then the stub logger will be automatically replaced with a real logger.

```typescript
import { getLogger } from "@ihr-radioedit/logger";

// No adapter is registered, so we get a stub with noop methods.
const logger = getLogger();

logger.info("Hello World", { key: "value" });
logger.error("This world sucks.");
logger.error(new Error("This world sucks more."), { key: "value" });

```

### With Adapter

Adapters provide a real implementation of the logger interface, and can be backed by native functionality
(e.g. `console`), or a third party library.

```typescript
// This import registers the pino adapter, and sets it as the default if no others are registered.
import "@ihr-radioedit/logger-pino";
import { getLogger } from "@ihr-radioedit/logger";

// This logger will actually do something.
const defaultLogger = getLogger();

// So will this one.
const pinoLogger = getLogger({ pretty: true }, null, "pino");

// Child loggers will inherit the adapter from their parent.
const childLogger = defaultLogger.child({ name: "componentA" });

defaultLogger.info("Hello World", { key: "value" });
pinoLogger.info("Hello World (pretty)", { key: "value" });
childLogger.info("Hello World (child)", { key: "value" });

```

## Environment

The following environment variables are supported:

| Variable Name          | Description                                                                     |
|------------------------|---------------------------------------------------------------------------------|
| `DEBUG`                | Set log level to `debug`, or even more verbose if one of the below requires it. |
| `LOG_LEVEL`            | The minimum log level to log, e.g. `debug`, `warn`, `error`, `45`               |
| `LOGGER_LEVEL`         | Same as `LOG_LEVEL`                                                             |
| `LOGGER_PRETTY_PRINT`  | Boolean for whether to pretty print logs.                                       |
| `LOGGER_EXIT_ON_FATAL` | Boolean for whether to exit the process on fatal errors.                        |

## Default Options

By default, the logging library uses the app id as the logger name, `info` as the level, does not pretty print, and
does not exit on fatal errors. You can set your own default options either with environment variables or by
using the `setDefaultOptions` helper function.

## Adapters

This library provides an abstract `LoggerBase` class which can be extended to create an adapter for a specific logging
library.

```typescript
import { LoggerBase, registerAdapter } from "@ihr-radioedit/logger";

export class MyLogger extends LoggerBase {
    // Implement the abstract properties and methods.
    readonly adapterName = "myLogger";

    log(level: string, message: string | Error, meta?: Record<string, unknown>) {
        // This renders a consistent message from a string or Error.
        const fullMessage = this.buildMessage(message);
        // This renders a consistent metadata object, including error details and logger context info.
        const fullMeta = this.buildMeta(meta);
        // do stuff with the fullMessage and fullMeta...
    }

    child(name: string, options?: Omit<LoggerOptions, "name">) {
        // Creating a child logger is usually just making an instance of the same class with a combined 
        // parent/child name.
        return new MyLogger({
            ...childOptions,
            name: this.childName(name),
        }, this);
    }

    // Override this to do some kind of cleanup when the process is exiting due to a fatal error.
    onFatalExit() {
        // do stuff...
    }
}

// Register the adapter.
registerAdapter("myLogger", opts => new MyLogger(opts));

```
