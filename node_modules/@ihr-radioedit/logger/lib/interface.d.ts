/**
 * Built-in log level values.
 */
export declare enum LogLevel {
    TRACE = 10,
    DEBUG = 20,
    INFO = 30,
    WARN = 40,
    ERROR = 50,
    FATAL = 60
}
/**
 * Function that logs a message with optional metadata (level decided elsewhere).
 */
export interface LogFn {
    <T extends NonNullable<unknown>>(msg: string | Error, meta?: T): void;
}
/**
 * Function that logs a message with level and optional metadata.
 */
export interface LevelLogFn {
    <T extends NonNullable<unknown>>(level: LogLevel | number, msg: string | Error, meta?: T): void;
}
/**
 * Adapter specific options. Use augmentation to add options for each adapter, preferably in the format:
 * `{ [adapterName]: { ...options } }`
 */
export interface LoggerAdapterOptions extends NonNullable<unknown> {
}
/**
 * Logger options, extensible for including adapter-specific options.
 */
export interface LoggerOptions<TAdapterOptions extends NonNullable<unknown> = LoggerAdapterOptions> {
    /**
     * Name of the logger. This is used to identify the logger in the logs, and to create child loggers.
     */
    name?: string;
    /**
     * Minimum log level to log. Should default to the parent's level, or if unset, `LogLevel.INFO`.
     */
    level?: LogLevel;
    /**
     * Whether to exit the process when a fatal log is made. Should default to `false`. In browsers, this will be
     * a no-op.
     */
    exitOnFatal?: boolean;
    /**
     * Whether to pretty-print logs. Should default to `false`.
     */
    pretty?: boolean;
    /**
     * Adapter specific options.
     */
    adapter?: TAdapterOptions & LoggerAdapterOptions;
    /**
     * Context to include in every log. This is useful for including common information such as the hostname, the
     * application name, etc.
     */
    context?: Record<string, string | boolean | number>;
}
/**
 * Logger interface which supports common and custom log levels, and child loggers.
 */
export interface Logger<TAdapterOptions extends NonNullable<unknown> = LoggerAdapterOptions, TNativeInstance = any> {
    /**
     * Name of the logger.
     */
    name: string;
    /**
     * Minimum log level to log.
     */
    level: LogLevel;
    /**
     * Name of the adapter.
     */
    readonly adapterName: string;
    /**
     * Log a message at level `TRACE`.
     */
    trace: LogFn;
    /**
     * Log a message at level `DEBUG`.
     */
    debug: LogFn;
    /**
     * Log a message at level `INFO`.
     */
    info: LogFn;
    /**
     * Log a message at level `WARN`.
     */
    warn: LogFn;
    /**
     * Log a message at level `ERROR`.
     */
    error: LogFn;
    /**
     * Log a message at level `FATAL`.
     */
    fatal: LogFn;
    /**
     * Log a message at the given level.
     */
    log: LevelLogFn;
    /**
     * Native logger instance (adapter specific). Not intended to be used outside of adapter code.
     */
    native?: TNativeInstance;
    /**
     * Get a child logger with the given name and options.
     * @param name Name of the child logger (should be combined with ancestor names when logging).
     * @param options Options for the child logger.
     */
    child(name: string, options?: Omit<LoggerOptions<TAdapterOptions>, "name">): Logger<TAdapterOptions>;
    /**
     * Configure the logger with the given options.
     * @param options Options for the logger.
     * @param replace Whether to replace the current configuration. Should default to `false`.
     */
    configure(options?: LoggerOptions<TAdapterOptions>, replace?: boolean): void;
    /**
     * Get the current logger configuration.
     */
    getConfig(): LoggerOptions<TAdapterOptions>;
}
/**
 * Function which returns a logger. Adapters have to implement this interface in order to register.
 */
export interface LoggerAdapter<TAdapterOptions extends NonNullable<unknown> = LoggerAdapterOptions> {
    (options?: LoggerOptions<TAdapterOptions>): Logger<TAdapterOptions>;
}
//# sourceMappingURL=interface.d.ts.map