import { LogLevel } from "./interface.js";
import { errorData } from "@ihr-radioedit/errors";
import { defaultOptions } from "./options.js";
import { isNode } from "@ihr-radioedit/sdk-utils";
import { isJsonable } from "./index.js";
/**
 * Base class for loggers.
 */
export class LoggerBase {
    parent;
    get name() {
        return this.config?.name ?? "";
    }
    get level() {
        return this.getConfig().level ?? LogLevel.INFO;
    }
    native;
    /**
     * Logger configuration. Subclasses should use accessor methods.
     */
    config;
    constructor(options, parent) {
        this.parent = parent;
        this.configure(options);
    }
    /**
     * Generate a new child logger name that includes the parent name.
     * @param name Name of the child logger.
     */
    childName(name) {
        return this.name ? `${this.name}.${name}` : name;
    }
    buildMeta(meta, err) {
        return {
            ...this.getConfig()?.context,
            ...(err && { errorDetail: errorData(err) }),
            ...(isJsonable(meta) ? meta.toJSON() : meta),
        };
    }
    buildMessage(msg) {
        if (msg instanceof Error) {
            const { message, stack, causedBy } = errorData(msg);
            const fullMsg = stack ?? message;
            return causedBy ? `${fullMsg} (caused by: ${causedBy.stack ?? causedBy.message})` : fullMsg;
        }
        return msg;
    }
    /**
     * Update the logger configuration. Merges with existing options unless `replace` is `true`.
     * @param options New options.
     * @param replace Whether to replace existing options.
     */
    configure(options, replace = false) {
        const merged = replace ? { ...options } : { ...this.config, ...options };
        this.config = this.parent ? merged : { ...defaultOptions(), ...merged };
    }
    getConfig() {
        return {
            ...this.parent?.getConfig(),
            ...this.config,
            context: { ...this.parent?.getConfig().context, ...this.config?.context },
        };
    }
    trace(msg, meta) {
        this.log(LogLevel.TRACE, msg, meta);
    }
    debug(msg, meta) {
        this.log(LogLevel.DEBUG, msg, meta);
    }
    info(msg, meta) {
        this.log(LogLevel.INFO, msg, meta);
    }
    warn(msg, meta) {
        this.log(LogLevel.WARN, msg, meta);
    }
    error(msg, meta) {
        this.log(LogLevel.ERROR, msg, meta);
    }
    /**
     * Called before the process exits due to a fatal error.
     */
    onFatalExit() {
        // Override me to do something before the process exits due to a fatal error.
    }
    fatal(msg, meta) {
        this.log(LogLevel.FATAL, msg, meta);
        if (isNode && this.getConfig()?.exitOnFatal) {
            this.onFatalExit();
            process.exit(1);
        }
    }
}
export const STUB_ADAPTER_NAME = "stub";
/**
 * Stub logger that does nothing (used if no adapters are registered).
 */
class StubLogger extends LoggerBase {
    static warned = false;
    adapterName = STUB_ADAPTER_NAME;
    log() {
        if (!StubLogger.warned) {
            console.warn("No logger adapters are registered. Using stub logger.");
            StubLogger.warned = true;
        }
    }
    child() {
        return this;
    }
}
/**
 * Stub logger that does nothing. This object is returned if no adapters are registered.
 */
export const loggerStub = new StubLogger();
const allProxies = [];
/**
 * Logger that proxies all calls to an instance of the default adapter (if present) or a stub implementation. This
 * is here so that logging can function even if there are no adapters registered.
 */
export class ProxyLogger extends LoggerBase {
    /**
     * Update the target of all proxy loggers to use the new adapter.
     * @param adapter Adapter to use.
     */
    static use(adapter) {
        for (const proxy of allProxies) {
            proxy.target = adapter(proxy.getConfig());
        }
    }
    /**
     * Target logger to proxy calls to.
     */
    target;
    get adapterName() {
        return (this.target ?? loggerStub).adapterName;
    }
    constructor(options, parent) {
        super(options, parent);
        allProxies.push(this);
    }
    log(level, msg, meta) {
        (this.target ?? loggerStub).log(level, msg, meta);
    }
    child(name, options) {
        return this.target
            ? this.target.child(name, options)
            : new ProxyLogger({
                ...options,
                name: this.childName(name),
            }, this);
    }
}
//# sourceMappingURL=builtin.js.map