import { Logger, LoggerAdapter, LoggerAdapterOptions, LoggerOptions, LogLevel } from "./interface.js";
/**
 * Base class for loggers.
 */
export declare abstract class LoggerBase<TAdapterOptions extends NonNullable<unknown> = LoggerAdapterOptions, TNativeInstance = any> implements Logger<TAdapterOptions, TNativeInstance> {
    protected parent?: Logger<TAdapterOptions, any> | undefined;
    /**
     * Name of the adapter.
     */
    abstract readonly adapterName: string;
    /**
     * Log a message at the given level.
     */
    abstract log<T extends NonNullable<unknown>>(level: LogLevel | number, msg: string | Error, meta?: T): void;
    /**
     * Create a child logger with the given name and options.
     */
    abstract child(name: string, options?: Omit<LoggerOptions<TAdapterOptions>, "name">): Logger<TAdapterOptions>;
    get name(): string;
    get level(): LogLevel;
    native?: TNativeInstance;
    /**
     * Logger configuration. Subclasses should use accessor methods.
     */
    private config?;
    constructor(options?: LoggerOptions<TAdapterOptions>, parent?: Logger<TAdapterOptions, any> | undefined);
    /**
     * Generate a new child logger name that includes the parent name.
     * @param name Name of the child logger.
     */
    protected childName(name: string): string;
    protected buildMeta<T extends NonNullable<unknown>>(meta?: T, err?: Error): {
        errorDetail?: import("@ihr-radioedit/errors").ErrorDataWithCause<{}, {}, {}> | undefined;
    };
    protected buildMessage(msg: string | Error): string;
    /**
     * Update the logger configuration. Merges with existing options unless `replace` is `true`.
     * @param options New options.
     * @param replace Whether to replace existing options.
     */
    configure(options?: LoggerOptions<TAdapterOptions>, replace?: boolean): void;
    getConfig(): LoggerOptions<TAdapterOptions>;
    trace(msg: string | Error, meta?: Record<string, unknown>): void;
    debug(msg: string | Error, meta?: Record<string, unknown>): void;
    info(msg: string | Error, meta?: Record<string, unknown>): void;
    warn(msg: string | Error, meta?: Record<string, unknown>): void;
    error(msg: string | Error, meta?: Record<string, unknown>): void;
    /**
     * Called before the process exits due to a fatal error.
     */
    protected onFatalExit(): void;
    fatal(msg: string | Error, meta?: Record<string, unknown>): void;
}
export declare const STUB_ADAPTER_NAME = "stub";
/**
 * Stub logger that does nothing (used if no adapters are registered).
 */
declare class StubLogger extends LoggerBase {
    protected static warned: boolean;
    readonly adapterName = "stub";
    log(): void;
    child(): this;
}
/**
 * Stub logger that does nothing. This object is returned if no adapters are registered.
 */
export declare const loggerStub: StubLogger;
/**
 * Logger that proxies all calls to an instance of the default adapter (if present) or a stub implementation. This
 * is here so that logging can function even if there are no adapters registered.
 */
export declare class ProxyLogger extends LoggerBase {
    /**
     * Update the target of all proxy loggers to use the new adapter.
     * @param adapter Adapter to use.
     */
    static use(adapter: LoggerAdapter<any>): void;
    /**
     * Target logger to proxy calls to.
     */
    target?: Logger<any>;
    get adapterName(): string;
    constructor(options?: LoggerOptions<any>, parent?: Logger<any>);
    log<T extends NonNullable<unknown>>(level: LogLevel | number, msg: string | Error, meta?: T): void;
    child(name: string, options?: Omit<LoggerOptions<any>, "name">): Logger<any>;
}
export {};
//# sourceMappingURL=builtin.d.ts.map