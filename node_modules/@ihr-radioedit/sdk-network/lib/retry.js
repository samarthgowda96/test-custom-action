import { EitherAsync, Left } from "purify-ts";
import { HttpStatus, RE_NETWORK_RETRIES, RE_NETWORK_RETRY_CODES, RetryStrategies } from "./const.js";
export function exponentialBackoff(base, jitter, scaleFactor, shouldRetry) {
    return {
        strategy: RetryStrategies.EXPONENTIAL,
        base,
        jitter,
        scaleFactor,
        shouldRetry,
    };
}
export function isExponentialRetryStrategy(x) {
    return typeof x === "object" && !!x && x["strategy"] === RetryStrategies.EXPONENTIAL;
}
export function linearBackoff(scaleFactor, shouldRetry) {
    return {
        strategy: RetryStrategies.LINEAR,
        scaleFactor,
        shouldRetry,
    };
}
export function isCustomRetryStrategy(x) {
    return typeof x === "object" && !!x && x["strategy"] === RetryStrategies.CUSTOM;
}
export function customBackoff(delay, scaleFactor, shouldRetry) {
    return {
        strategy: RetryStrategies.CUSTOM,
        delay,
        scaleFactor,
        shouldRetry,
    };
}
export function isRetryConfig(x) {
    return typeof x === "object";
}
/**
 * Retry implementation for `NetworkClientInterface` requests.
 * @param fn Function to execute.
 * @param retries Number of retries to attempt with default settings, or a `RetryConfig`.
 * @param logger Optional logger instance to record retry activity.
 * @see NetworkClientInterface
 * @see RetryConfig
 */
export function withRetries(fn, retries = RE_NETWORK_RETRIES, logger) {
    let start;
    const cfg = {
        strategy: exponentialBackoff(10, true, 1),
        ...(isRetryConfig(retries) ? retries : { retries }),
    };
    const maxRetries = cfg.retries ?? 3;
    let resultLazy = fn().ifLeft(() => (start = Date.now()));
    let retryCount = 0;
    let passthru = false;
    const noRetry = (e) => {
        passthru = true;
        return EitherAsync.liftEither(Left(e));
    };
    for (let i = 0; i < maxRetries; i++) {
        resultLazy = resultLazy.chainLeft(e => {
            if (passthru) {
                // We've already failed the whole operation due to a timeout, so just return the error.
                return noRetry(e);
            }
            // Note: attempt 0 is the initial request, so we start at 1 for retries.
            retryCount++;
            const now = Date.now();
            if (cfg.timeout && now > start + cfg.timeout) {
                logger?.error(`Retries timed out after ${now - start}ms`, { attempt: retryCount });
                return noRetry(e);
            }
            if (cfg.strategy?.shouldRetry?.(cfg, retryCount, e) ?? RE_NETWORK_RETRY_CODES.includes(e.response.status)) {
                // If for some reason the caller passes a bogus strategy name, and we're not dealing with a Retry-After
                // header, the delay will be 0 and we'll retry immediately.
                let delay = 0;
                const retryAfterHeader = (e.response.headers.get("retry-after") ?? "").trim();
                const retryAfterNum = retryAfterHeader ? parseInt(retryAfterHeader, 10) : null;
                const retryAfterDate = retryAfterHeader ? new Date(retryAfterHeader) : null;
                const retryAfter = typeof retryAfterNum === "number" && !isNaN(retryAfterNum)
                    ? now + retryAfterNum * 1000
                    : retryAfterDate instanceof Date && !isNaN(retryAfterDate.valueOf())
                        ? retryAfterDate.valueOf()
                        : null;
                if (retryAfter &&
                    [HttpStatus.PERMANENT_REDIRECT, HttpStatus.TOO_MANY_REQUESTS, HttpStatus.GATEWAY_TIMEOUT].includes(e.response.status)) {
                    if (cfg.timeout && retryAfter > start + cfg.timeout) {
                        logger?.error(`Retries will time out before the next retry can be attempted at ${new Date(retryAfter).toISOString()}`, { attempt: retryCount });
                        return noRetry(e);
                    }
                    delay = retryAfter - now;
                }
                else if (isExponentialRetryStrategy(cfg.strategy)) {
                    delay = cfg.strategy.base ** retryCount * (cfg.strategy.scaleFactor ?? 1);
                    if (cfg.strategy.jitter) {
                        /*
                            We need to pad the range a little bit on the first retry, because otherwise we'll always
                            get the base and no jitter will happen.
                         */
                        const range = delay - cfg.strategy.base > 0 ? delay - cfg.strategy.base : delay - cfg.strategy.base + 10;
                        // Adding 1 to the range makes the max value inclusive.
                        delay = Math.floor(Math.random() * (range + 1) + cfg.strategy.base);
                    }
                }
                else if (isCustomRetryStrategy(cfg.strategy)) {
                    delay = cfg.strategy.delay(cfg, retryCount);
                }
                else if (cfg.strategy?.strategy === RetryStrategies.LINEAR) {
                    delay = (cfg.strategy.scaleFactor ?? 1) * retryCount;
                }
                if (cfg.timeout && delay > 0 && now + delay > start + cfg.timeout) {
                    logger?.error(`Retries will time out before next retry can be attempted at ${new Date(now + delay).toISOString()}`, { attempt: retryCount });
                    return noRetry(e);
                }
                logger?.debug(`Retrying request in ${delay}ms`, { attempt: retryCount, delay });
                return EitherAsync(() => new Promise(resolve => setTimeout(resolve, delay))).chain(fn);
            }
            else {
                return noRetry(e);
            }
        });
    }
    return resultLazy
        .mapLeft(e => {
        e.response.retryCount = retryCount;
        return e;
    })
        .map(r => {
        r.retryCount = retryCount;
        return r;
    });
}
//# sourceMappingURL=retry.js.map