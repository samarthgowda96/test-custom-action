import { Logger } from "@ihr-radioedit/logger";
import { ErrorBase, ErrorData } from "@ihr-radioedit/errors";
import { EitherAsync } from "purify-ts";
import { HttpMethod, HttpStatus, RetryStrategies } from "./const.js";
/**
 * Retry strategy configuration.
 */
export interface RetryStrategy {
    /**
     * Strategy to use for retries.
     */
    strategy: RetryStrategies;
    /**
     * Factor by which to increase (or decrease) the backoff times calculated for each strategy.
     */
    scaleFactor?: number;
    /**
     * Function to determine whether a request should be retried. Implementations should supply a default if not set.
     * @param config The retry configuration.
     * @param attempt The number of the current attempt (starting at 1).
     * @param err The error that caused the request to fail.
     */
    shouldRetry?: <T, U>(config: RetryConfig, attempt: number, err: NetworkFailure<T, U>) => boolean;
}
/**
 * Exponential backoff strategy configuration.
 */
export interface ExponentialRetryStrategy extends RetryStrategy {
    strategy: RetryStrategies.EXPONENTIAL;
    /**
     * Base time (in milliseconds) to use for exponential backoff.
     */
    base: number;
    /**
     * Whether to add jitter to the backoff time. This will cause the actual backoff time to be a random value between
     * 0 and the calculated backoff time.
     */
    jitter?: boolean;
}
/**
 * Linear backoff strategy configuration.
 */
export interface LinearRetryStrategy extends RetryStrategy {
    strategy: RetryStrategies.LINEAR;
}
/**
 * Custom retry strategy configuration.
 */
export interface CustomRetryStrategy extends RetryStrategy {
    strategy: RetryStrategies.CUSTOM;
    /**
     * Function to determine how long to wait before retrying a request.
     * @param config The retry configuration.
     * @param attempt The number of the current attempt (starting at 1).
     */
    delay: (config: RetryConfig, attempt: number) => number;
}
/**
 * Configuration for retrying failed requests.
 * @see RetryStrategy
 */
export interface RetryConfig {
    /**
     * The total number of retries to attempt before failure.
     */
    retries?: number;
    /**
     * Retry strategy to use.
     */
    strategy?: RetryStrategy;
    /**
     * Total time allowed to complete an action once retries begin. Implementations should not retry after this time,
     * but should allow in-progress requests to complete.
     */
    timeout?: number;
}
/**
 * Type[s] allowed to be used as a request body in a `NetworkClientInterface`.
 * @see NetworkClient
 */
export type RequestBody<T> = string | ReadableStream<T> | ArrayBuffer | FormData;
/**
 * Default type for adapter-specific options. Use type augmentation to extend, e.g.:
 * ```
 * declare module "@ihr-radioedit/network" {
 *     interface AdapterOptions {
 *         myAdapter?: {
 *             myOption?: string;
 *         }
 *     }
 * }
 * ```
 */
export interface AdapterOptions {
}
/**
 * Configuration for a network request. Can also be used as default values for all requests in a
 * NetworkInterface instance.
 *
 *
 *
 * https://axios-http.com/docs/req_config
 * https://github.com/sindresorhus/got/blob/main/documentation/2-options.md
 *
 * Notes:
 *  - Got has a json option that will automatically stringify the body and set the content-type header, as opposed to
 *    axios doing it implicitly.
 *  - and a form option that will send x-www-form-urlencoded data.
 *  - and a context object that can be used within hooks (this seems kinda pointless, but maybe not).
 */
export interface RequestOptions<TAdapterOptions extends NonNullable<unknown> = AdapterOptions> {
    /**
     * Base URL to use for relative URLs.
     */
    baseUrl?: string | URL;
    /**
     * Query string parameters to append to the URL. Callers will have to perform their own serialization of values if
     * the standard URLSearchParams stringify won't do.
     */
    params?: URLSearchParams;
    /**
     * Retry configuration. Adapters may include retries in the request flow by default, if this parameter is not set.
     * @see RetryConfig
     */
    retries?: RetryConfig | number;
    /**
     * Headers to send with the request.
     */
    headers?: Headers;
    /**
     * Send credentials with the request (or not). This has different behavior depending on the adapter and environment.
     * In browsers, this will set the `withCredentials` flag on the request. In Node, this is a no-op if an
     * Authorization header is set; otherwise, the RadioEdit app token will be used if available.
     */
    withCredentials?: boolean;
    /**
     * Enable (or not) keepalive in the request, where supported.
     */
    keepalive?: boolean;
    /**
     * Timeout configuration. Adapters should default to having no timeouts.
     */
    timeout?: {
        /**
         * Max time from the moment of request initiation until a connection is made to the remote host. This option may
         * not be supported by all adapters.
         */
        connect?: number;
        /**
         * Max time from the moment a connection is made to the complete receipt of the response. This option may not
         * be supported by all adapters.
         */
        response?: number;
        /**
         * Timeout for the full request duration, from the moment of initiation to the complete receipt of the response.
         * All adapters should support this option.
         */
        overall?: number;
    };
    /**
     * Signal for aborting the request. Use this option to enforce a timeout on the full request duration.
     * Adapters should attach to this and abort the request if it is triggered.
     */
    signal?: AbortSignal;
    /**
     * Adapter-specific options.
     */
    adapterOptions?: TAdapterOptions;
}
export type MergedOptions<T extends NonNullable<unknown> = AdapterOptions> = Omit<RequestOptions<T>, "headers" | "params"> & {
    headers: Headers;
    params: URLSearchParams;
};
/**
 * Hooks for modifying the request at various stages. May be extended by adapters to provide additional hooks.
 */
export interface RequestInterceptor {
    /**
     * Called before the request is sent
     * @param options
     */
    onConfigure?: <T extends NonNullable<unknown> = AdapterOptions>(options: Readonly<MergedOptions<T>>) => MergedOptions<T>;
}
/**
 * Hooks for modifying the response at various stages. May be extended by adapters to provide additional hooks.
 */
export interface ResponseInterceptor {
    /**
     * Called after the response is received. The default behavior for adapters on status check should be to accept
     * 2xx codes as success and reject the rest.
     * @param response
     */
    onStatusCheck?: <T, U>(response: NetworkResponse<T, U>) => {
        ok: boolean;
        errorMessage?: string;
    };
    /**
     * Called after a request is successfully completed.
     * @param response
     */
    onSuccess?: <T, U>(response: NetworkResponse<T, U>) => NetworkResponse<T, U>;
    /**
     * Called after a request fails.
     * @param error
     */
    onFailure?: <T, U>(error: NetworkFailure<T, U>) => NetworkFailure<T, U>;
}
/**
 * Client level configuration options. Can be used to set default values for all requests in a `NetworkClientInterface`.
 * @see RequestOptions
 * @see NetworkClient
 */
export interface NetworkClientConfig<TAdapterOptions extends NonNullable<unknown> = AdapterOptions> {
    /**
     * List of functions that can modify the request config before it is sent.
     */
    interceptors?: {
        /**
         * Called before the request is sent.
         */
        request?: RequestInterceptor[];
        /**
         * Called after the response is received.
         */
        response?: ResponseInterceptor[];
    };
    /**
     * Logger instance for adapters to use. They should not perform any logging if this parameter is unset.
     * When set, adapters should provide debug-level logs for the request and response.
     */
    logger?: Logger<any>;
    /**
     * Default options to use for all requests. Adapters should merge these options with request-specific options
     * as follows:
     *   - headers: convert to Headers object and use `.set()` to merge with request headers.
     *   - params: convert to URLSearchParams and use `.append()` to merge with request params.
     *   - signal: it makes no sense to have a default abort signal, but adapters may wedge their own `AbortController`
     * in between the user's signal and the request if desired, on a per request basis.
     *   - all other options: take request options as overrides.
     */
    defaultOptions?: Omit<RequestOptions<TAdapterOptions>, "signal">;
}
/**
 * Represents a client instsance that is configurable and can be used to make network requests.
 */
export interface NetworkClient<TAdapterOptions extends NonNullable<unknown> = AdapterOptions, TAdapterResponse = any> {
    /**
     * Get the current configuration for this client.
     */
    getConfig(): NetworkClientConfig<TAdapterOptions>;
    /**
     * Update the configuration for this client.
     * @param value
     */
    configure: (value: NetworkClientConfig<TAdapterOptions>) => void;
    /**
     * Make an HTTP DELETE request.
     * @param path Path or URL to send the request to.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    delete: <T>(path: string | URL, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<T, TAdapterResponse>>;
    /**
     * Make an HTTP GET request.
     * @param path Path or URL to send the request to.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    get: <T>(path: string | URL, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<T, TAdapterResponse>>;
    /**
     * Make an HTTP HEAD request.
     * @param path Path or URL to send the request to.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    head: (path: string | URL, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<null, TAdapterResponse>>;
    /**
     * Make an HTTP POST request.
     * @param path Path or URL to send the request to.
     * @param body Request body. Adapters should *not* set the conent-type header, in favor of helper functions.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    post: <T, U>(path: string | URL, body?: RequestBody<T>, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<U, TAdapterResponse>>;
    /**
     * Make an HTTP PUT request.
     * @param path Path or URL to send the request to.
     * @param body Request body. Adapters should *not* set the conent-type header, in favor of helper functions.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    put: <T, U>(path: string | URL, body: RequestBody<T>, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<U, TAdapterResponse>>;
    /**
     * Make a network request. Adapters should perform validation, e.g. that no body is supplied with a GET request.
     * Request interceptors should be applied before request initiation.
     * @param method HTTP method to use.
     * @param url URL to send the request to, or path relative to the `baseUrl` in configuration/options.
     * @param body Request body. Adapters should *not* set the conent-type header, in favor of helper functions.
     * @param options Request options. Adapters should merge these with the client's default options.
     */
    request: <T, U>(method: HttpMethod | string, url: string | URL, body?: RequestBody<T>, options?: RequestOptions<TAdapterOptions>) => EitherAsync<NetworkFailure<unknown, TAdapterResponse>, NetworkResponse<U, TAdapterResponse>>;
}
/**
 * Represents a network response received by a `NetworkClientInterface`.
 * @see NetworkClient
 */
export interface NetworkResponse<TJson, TAdapterResponse = any> {
    /**
     * Raw response body.
     */
    data: ReadableStream<Uint8Array>;
    /**
     * Response headers.
     */
    headers: Headers;
    /**
     * Response status line code.
     */
    status: HttpStatus | number;
    /**
     * Response status line text.
     */
    statusText: string;
    /**
     * Number of times the request was retried before succeeding or giving up.
     */
    retryCount: number;
    /**
     * Convenience method to get the response body as plain text.
     */
    text: () => Promise<string>;
    /**
     * Convenience method to get the response body as JSON.
     */
    json: () => Promise<TJson>;
    /**
     * Get the adapter-specific response object. This shouldn't be needed for most use cases.
     */
    response: () => TAdapterResponse;
    /**
     * Get the response body as a blob.
     */
    blob: () => Promise<Blob>;
}
/**
 * Additional detail for network errors.
 */
export interface NetworkFailureDetail {
    statusText: string;
    headers: Record<string, string>;
    retryCount: number;
}
/**
 * Represents a network error thrown by a `NetworkClientInterface`.
 * @see NetworkClient
 */
export interface NetworkFailure<TData = unknown, TAdapterResponse = any> extends ErrorBase<NetworkFailureDetail> {
    response: NetworkResponse<TData, TAdapterResponse>;
    toErrorData(): ErrorData<NetworkFailureDetail>;
}
/**
 * Constructor type for `NetworkClient` implementations.
 * @see NetworkClient
 */
export type NetworkClientConstructor<TAdapterOptions extends NonNullable<unknown> = AdapterOptions> = new (options?: NetworkClientConfig<TAdapterOptions>) => NetworkClient<TAdapterOptions>;
//# sourceMappingURL=interface.d.ts.map