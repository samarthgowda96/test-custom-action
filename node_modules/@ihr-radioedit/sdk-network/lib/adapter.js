import { Left, Right } from "purify-ts";
import { HttpStatus } from "./const.js";
import { ResponseNotAvailable } from "./errors/response-not-available.js";
import { NetworkError } from "./errors/base.js";
/**
 * Merge a request URL with the client base URL and set query string parameters.
 *
 * @param url request URL
 * @param baseUrl client base URL
 * @param params query string parameters
 */
export function mergeUrl(url, baseUrl, params) {
    return Object.assign(new URL(url.toString(), baseUrl), {
        search: params?.toString() ?? "",
    });
}
/**
 * Wrap (or create) an abort signal with a timeout. This will immediately start the timer, so don't call until you're
 * ready to send the request.
 *
 * @param signal abort signal passed in by the user.
 * @param timeout timeout in milliseconds.
 */
export function wrapSignal(signal, timeout) {
    if (timeout) {
        const ctl = new AbortController();
        const timer = setTimeout(() => ctl.abort(), timeout);
        if (signal) {
            signal.addEventListener("abort", () => {
                ctl.abort();
                clearTimeout(timer);
            });
        }
        return { signal: ctl.signal, timer };
    }
    return { signal };
}
/**
 * Create a response object with no data and the given status.
 * @param status HTTP status code.
 * @param statusText HTTP status text.
 */
export function createEmptyResponse(status = HttpStatus.UNKNOWN_CLIENT_FAILURE, statusText = "Client Failure") {
    const respErr = new ResponseNotAvailable("No response was received, or it was unreadable.");
    return {
        status,
        statusText,
        retryCount: 0,
        headers: new Headers(),
        data: new ReadableStream({ start: controller => controller.enqueue(Uint8Array.from([])) }),
        response: () => {
            throw respErr;
        },
        text: () => Promise.reject(respErr),
        json: () => Promise.reject(respErr),
        blob: () => Promise.reject(respErr),
    };
}
/**
 * Check the status of a NetworkResponse and convert it to a NetworkError if it's not ok.
 * @param resp NetworkResponse to check.
 * @param interceptors response interceptors.
 */
export function checkStatus(resp, interceptors) {
    const statusChecks = (interceptors ?? []).map(interceptor => interceptor.onStatusCheck?.(resp) ?? { ok: true });
    const firstFailure = statusChecks.length > 0 ? statusChecks.find(check => !check.ok) : undefined;
    if (firstFailure || (statusChecks.length === 0 && (resp.status < 200 || resp.status >= 300))) {
        return Left(NetworkError.fromResponse(resp, firstFailure?.errorMessage));
    }
    return Right(resp);
}
/**
 * Process a NetworkResponse through the response interceptors.
 * @param resp NetworkResponse to process.
 * @param interceptors response interceptors.
 */
export function applySuccessInterceptors(resp, interceptors) {
    interceptors?.forEach(interceptor => {
        if (interceptor.onSuccess) {
            resp = interceptor.onSuccess(resp);
        }
    });
    return resp;
}
/**
 * Process a NetworkError through the response interceptors.
 * @param err NetworkError to process.
 * @param interceptors response interceptors.
 */
export function applyFailureInterceptors(err, interceptors) {
    interceptors?.forEach(interceptor => {
        if (interceptor.onFailure) {
            err = interceptor.onFailure(err);
        }
    });
    return err;
}
/**
 * Convert a ReadableStream to a Blob.
 * @param stream ReadableStream to convert.
 */
export function streamToBlob(stream) {
    return new Response(stream).blob();
}
//# sourceMappingURL=adapter.js.map