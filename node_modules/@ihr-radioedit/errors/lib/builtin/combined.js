import { ErrorBase } from "../base.js";
import { deserializeError, registerErrorDeserializer } from "../registry.js";
/**
 * Generic type for an error that's bundling other errors, e.g. a GraphQL response or a validation result.
 */
export class CombinedError extends ErrorBase {
    errors = [];
    code = "EMPTY_COMBINED_ERROR";
    constructor(message) {
        super(message ?? "Empty combined error");
    }
    static fromErrors(errors, overallCode, overallMessage) {
        const code = overallCode ?? errors[0]?.toErrorData().code ?? "EMPTY_COMBINED_ERROR";
        const combined = new CombinedError(overallMessage ?? errors[0]?.message ?? "Empty combined error");
        combined.code = code;
        combined.errors = errors;
        return combined;
    }
    static fromErrorData(data) {
        const combined = new CombinedError(data.message);
        combined.code = data.code;
        combined.stack = data.stack;
        combined.errors = data.detail?.allErrors?.map(e => deserializeError(e)) ?? [];
        return combined;
    }
    toErrorData() {
        return {
            name: this.name,
            message: this.message,
            stack: this.stack,
            code: this.code ?? this.errors[0]?.toErrorData().code ?? "EMPTY_COMBINED_ERROR",
            detail: { allErrors: this.errors.map(e => e.toErrorData()) },
        };
    }
}
registerErrorDeserializer("CombinedError", CombinedError.fromErrorData);
//# sourceMappingURL=combined.js.map